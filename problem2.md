经过$A \rarr B$这条调用栈达到的其他调用栈被称为其子调用栈
如 $A \rarr B \rarr D$ 是 $A \rarr B$ 的子调用栈
通过分析工具对调用栈进行采样分析，得到树形结构，每个节点代表一条调用栈，子节点为父节点的子调用栈，每个节点有一个数值为采样到该调用栈的样本数量。
现在需要刷新个节点的数值为包含其子调用栈的总样本数量，请编码实现：

树的层序遍历，指的是从上到下遍历每层，每层从左到右遍历个节点，为了标识子节点关系，对于$N$个节点的树的层遍历，插入 $N$ 个 $-1$.第 $i$ 个 $-1$ 和第 $i+1$ 个 $-1$ 中间的节点序列为第i个节点的子节点序列，根节点为第一个节点。

输入：
第一行为树的总节点数量 $N$，取值范围$[1,1000]$;
第二行为树的序列化输入，采用层序遍历，共 $2N$ 个数据，包括$N$个节点的样本数和$N$个节点的子节点序列的分隔符（参见示例）；各节点样本数取值范围$[0,10000]$

输出：
输出刷新各节点数值后的树，与输入格式保持一致

样例1
输入：

```
6
5 -1 2 3 8 -1 -1 1 7 -1 -1 -1
```

输出：

```
26 -1 2 11 8 -1 -1 1 7 -1 -1 -1
```

解释：
第一行表示树一共有$6$个节点;
第二行为按章层序遍历的序列化输入，共$12$个数据（包含$6$个节点的样本数和$6$个节点的子节点序列的分隔符），含义分别为：

```
 5： 第一个节点 （即根节点），样本数为5；
-1：分隔第一个节点（即根节点）的子节点序列；
2： 第二个节点的样本数为2，它是根节点的第一个子节点；
3：第三个节点的样本数为3，它是根节点的第二个子节点；
8：第四个节点的样本数为8，它是根节点的第三个子节点；
-1：分隔第二个节点的子节点序列，后续无有效值，表示该节点无子节点；
-1：分隔第三个节点的子节点序列；
1：第五个节点的样本数为1，它是第三个节点的第一个子节点；
7:第六个节点的样本数为7，它是第三个节点的第二个子节点；
-1：分隔第四个节点的子节点序列，后续无有效值，表示该节点无子节点；
-1：分隔第五个节点的子节点序列，后续无有效值，表示该节点无子节点；
-1：分隔第六个节点的子节点序列，后续无有效值，表示该节点无子节点；
```

构造输入树形结构：
$5(A)\rarr \begin{cases}2(A\rarr B),\\ 3(A\rarr C)\rarr \begin{cases}1(A\rarr C\rarr E)\\ 7(A\rarr C\rarr F)\end{cases},\\ 8(A\rarr D)\end{cases}$
根据树形结构计算各节点包含子节点的样本数:
调用栈$A\rarr C$有子调用栈$A\rarr C\rarr E$和$A\rarr C\rarr F$，所以其包含子调用栈的样本数为 $3+1+7 =1$：第五个节点的样本数为$1$，它是第三个节点的第一个子节点；
根节点调用栈$A$包含的子调用 栈$A\rarr B,A\rarr C,A\rarr D$，其包含子调用栈的样本数为 5+2+11+8=26.
刷新后的调用栈树按照层序遍历序列化输出为 `26 -1 2 11 8 -1 -1 1 7 -1 -1 -1`
